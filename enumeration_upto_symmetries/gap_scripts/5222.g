LoadPackage("json");

#Define the Symmetry Group
GRP_RED := Group((33,65)(34,66)(35,67)(36,68)(37,69)(38,70)(39,71)(40,72)(41,73)(42,74)(43,75)(44,76)(45,77)(46,78)(47,79)(48,80)(49,81)(50,82)(51,83)(52,84)(53,85)(54,86)(55,87)(56,88)(57,89)(58,90)(59,91)(60,92)(61,93)(62,94)(63,95)(64,96),
(17,65)(18,66)(19,67)(20,68)(21,69)(22,70)(23,71)(24,72)(25,73)(26,74)(27,75)(28,76)(29,77)(30,78)(31,79)(32,80)(49,97)(50,98)(51,99)(52,100)(53,101)(54,102)(55,103)(56,104)(57,105)(58,106)(59,107)(60,108)(61,109)(62,110)(63,111)(64,112),
(9,65)(10,66)(11,67)(12,68)(13,69)(14,70)(15,71)(16,72)(25,81)(26,82)(27,83)(28,84)(29,85)(30,86)(31,87)(32,88)(41,97)(42,98)(43,99)(44,100)(45,101)(46,102)(47,103)(48,104)(57,113)(58,114)(59,115)(60,116)(61,117)(62,118)(63,119)(64,120),
(5,65)(6,66)(7,67)(8,68)(13,73)(14,74)(15,75)(16,76)(21,81)(22,82)(23,83)(24,84)(29,89)(30,90)(31,91)(32,92)(37,97)(38,98)(39,99)(40,100)(45,105)(46,106)(47,107)(48,108)(53,113)(54,114)(55,115)(56,116)(61,121)(62,122)(63,123)(64,124),
(2,3)(6,7)(10,11)(14,15)(18,19)(22,23)(26,27)(30,31)(34,35)(38,39)(42,43)(46,47)(50,51)(54,55)(58,59)(62,63)(66,67)(70,71)(74,75)(78,79)(82,83)(86,87)(90,91)(94,95)(98,99)(102,103)(106,107)(110,111)(114,115)(118,119)(122,123)(126,127),
(1,65)(2,66)(3,67)(4,68)(5,69)(6,70)(7,71)(8,72)(9,73)(10,74)(11,75)(12,76)(13,77)(14,78)(15,79)(16,80)(17,81)(18,82)(19,83)(20,84)(21,85)(22,86)(23,87)(24,88)(25,89)(26,90)(27,91)(28,92)(29,93)(30,94)(31,95)(32,96)(33,97)(34,98)(35,99)(36,100)(37,101)(38,102)(39,103)(40,104)(41,105)(42,106)(43,107)(44,108)(45,109)(46,110)(47,111)(48,112)(49,113)(50,114)(51,115)(52,116)(53,117)(54,118)(55,119)(56,120)(57,121)(58,122)(59,123)(60,124)(61,125)(62,126)(63,127)(64,128),
(1,3)(2,4)(5,7)(6,8)(9,11)(10,12)(13,15)(14,16)(17,19)(18,20)(21,23)(22,24)(25,27)(26,28)(29,31)(30,32)(33,35)(34,36)(37,39)(38,40)(41,43)(42,44)(45,47)(46,48)(49,51)(50,52)(53,55)(54,56)(57,59)(58,60)(61,63)(62,64)(65,67)(66,68)(69,71)(70,72)(73,75)(74,76)(77,79)(78,80)(81,83)(82,84)(85,87)(86,88)(89,91)(90,92)(93,95)(94,96)(97,99)(98,100)(101,103)(102,104)(105,107)(106,108)(109,111)(110,112)(113,115)(114,116)(117,119)(118,120)(121,123)(122,124)(125,127)(126,128));
# Storage for all polytopes found
all_polys := [];
max_recursion := 30;
for i in [1..max_recursion] do
    Add(all_polys, []);
od;

# setup files

outfile := IO_File(Concatenation(IO_getcwd(), "/fromgap.pipe"), "w");
infile := IO_File(Concatenation(IO_getcwd(), "/togap.pipe"), "r");

while true do
        # read command from input
        str := IO_ReadLine(infile);
        if str <> "" then
            # Print("GAP READ: ", str);
            # Convert to GAP Object
            arr := JsonStringToGap(str);
            # Extract Level
            level := arr[1][1] + 1;

            Remove(arr,1);
            if level > max_recursion then
                Print("WATCH OUT: MAX RECURSION LEVEL IN GAP REACHED");
            fi;

            response := [];
            for i in [1..Length(arr)] do
                cpoly := arr[i];
                equiv := 0;
                for tpoly in all_polys[level] do
                    res := RepresentativeAction(GRP_RED, tpoly, cpoly, OnSets);
                    if res <> fail then
                        equiv := 1;
                        break;
                    fi;
                od;
                if equiv = 0 then
                    Add(all_polys[level], cpoly);
                    Add(response, i-1);
                    Print("Level ", level, ": ",  Length(all_polys[level]), "\n");
                fi;
            od;
            # write false in case there is no equivalent polytope
            if Length(response) = 0 then
                IO_WriteLine(outfile, "false");
            else
                IO_WriteLine(outfile, response);
            fi;
        fi;
od;
